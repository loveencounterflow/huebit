{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/single-file-modules.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n############################################################################################################\n#\n#===========================================================================================================\nmodule.exports = SFMODULES =\n\n  #===========================================================================================================\n  ### NOTE Future Single-File Module ###\n  require_list_tools: ->\n    append    = ( list, P... ) -> list.splice list.length, 0, P...\n    is_empty  = ( list ) -> list.length is 0\n    return { append, is_empty, }\n\n  #===========================================================================================================\n  ### NOTE Future Single-File Module ###\n  require_escape_html_text: ->\n    escape_html_text = ( text ) ->\n      R = text\n      R = R.replace /&/g, '&amp;'\n      R = R.replace /</g, '&lt;'\n      R = R.replace />/g, '&gt;'\n      return R\n    return { escape_html_text, }\n\n  #===========================================================================================================\n  ### NOTE Future Single-File Module ###\n  require_tagfun_tools: ->\n\n    # ### Given the arguments of either a tagged template function call ('tagfun call') or the single\n    # argument of a conventional function call, `get_first_argument()` will return either\n\n    # * the result of applying `as_text()` to the sole argument, or\n\n    # * the result of concatenating the constant parts and the interpolated expressions, which each\n    # expression replaced by the result of applying `as_text()` to it.\n\n    # Another way to describe this behavior is to say that this function treats a conventional call with\n    # a single expression the same way that it treats a funtag call with a string that contains nothing but\n    # that same expression, so the invariant `( get_first_argument exp ) == ( get_first_argument\"#{ exp }\"\n    # )` holds.\n\n    # * intended for string producers, text processing, markup production;\n    # * list some examples. ###\n\n    # #---------------------------------------------------------------------------------------------------------\n    # create_get_first_argument_fn = ( as_text = null ) ->\n    #   as_text ?= ( expression ) -> \"#{expression}\"\n    #   ### TAINT use proper validation ###\n    #   unless ( typeof as_text ) is 'function'\n    #     throw new Error \"Ωidsp___1 expected a function, got #{rpr as_text}\"\n    #   #-------------------------------------------------------------------------------------------------------\n    #   get_first_argument = ( P... ) ->\n    #     unless is_tagfun_call P...\n    #       unless P.length is 1\n    #         throw new Error \"Ωidsp___2 expected 1 argument, got #{P.length}\"\n    #       return as_text P[ 0 ]\n    #     #.....................................................................................................\n    #     [ parts, expressions..., ] = P\n    #     R = parts[ 0 ]\n    #     for expression, idx in expressions\n    #       R += ( as_text expression ) + parts[ idx + 1 ]\n    #     return R\n    #   #-------------------------------------------------------------------------------------------------------\n    #   get_first_argument.create = create_get_first_argument_fn\n    #   return get_first_argument\n\n    #---------------------------------------------------------------------------------------------------------\n    is_tagfun_call = ( P... ) ->\n      return false unless Array.isArray   P[ 0 ]\n      return false unless Object.isFrozen P[ 0 ]\n      return false unless P[ 0 ].raw?\n      return true\n\n    #---------------------------------------------------------------------------------------------------------\n    walk_raw_parts = ( chunks, values... ) ->\n      chunks      = ( chunk for chunk in chunks.raw )\n      chunks.raw  = chunks[ ... ]\n      Object.freeze chunks\n      yield from walk_parts chunks, values...\n\n    #---------------------------------------------------------------------------------------------------------\n    walk_parts = ( chunks, values... ) ->\n      unless is_tagfun_call chunks, values...\n        if values.length isnt 0\n          throw new Error \"Ω___3 expected 1 argument in non-template call, got #{arguments.length}\"\n        if typeof chunks is 'string' then [ chunks, values, ] = [ [ chunks, ], [],          ]\n        else                              [ chunks, values, ] = [ [ '', '', ], [ chunks, ], ]\n      #.......................................................................................................\n      yield { chunk: chunks[ 0 ], isa: 'chunk', }\n      for value, idx in values\n        yield { value, isa: 'value', }\n        yield { chunk: chunks[ idx + 1 ], isa: 'chunk', }\n      #.......................................................................................................\n      return null\n\n    #---------------------------------------------------------------------------------------------------------\n    walk_raw_nonempty_parts = ( chunks, values... ) ->\n      for part from walk_raw_parts chunks, values...\n        yield part unless ( part.chunk is '' ) or ( part.value is '' )\n      return null\n\n    #---------------------------------------------------------------------------------------------------------\n    walk_nonempty_parts = ( chunks, values... ) ->\n      for part from walk_parts chunks, values...\n        yield part unless ( part.chunk is '' ) or ( part.value is '' )\n      return null\n\n    #---------------------------------------------------------------------------------------------------------\n    # return do exports = ( get_first_argument = create_get_first_argument_fn() ) -> {\n    #   get_first_argument, is_tagfun_call,\n    #   walk_parts, walk_nonempty_parts, walk_raw_parts, walk_raw_nonempty_parts, }\n    return {\n      is_tagfun_call,\n      walk_parts,           walk_raw_parts,\n      walk_nonempty_parts,  walk_raw_nonempty_parts, }\n\n\n  #===========================================================================================================\n  ### NOTE Future Single-File Module ###\n  require_managed_property_tools: ->\n    set_getter = ( object, name, get ) -> Object.defineProperties object, { [name]: { get, }, }\n    hide = ( object, name, value ) => Object.defineProperty object, name,\n        enumerable:   false\n        writable:     true\n        configurable: true\n        value:        value\n\n    #---------------------------------------------------------------------------------------------------------\n    return { set_getter, hide, }\n\n  #===========================================================================================================\n  ### NOTE Future Single-File Module ###\n  require_nameit: ->\n    nameit = ( name, fn ) -> Object.defineProperty fn, 'name', { value: name, }; fn\n    #---------------------------------------------------------------------------------------------------------\n    return { nameit, }\n\n  #===========================================================================================================\n  ### NOTE Future Single-File Module ###\n  require_stack_classes: ->\n    { set_getter,\n      hide,       } = SFMODULES.require_managed_property_tools()\n    misfit          = Symbol 'misfit'\n    class XXX_Stack_error extends Error\n\n    #===========================================================================================================\n    class Stack\n\n      #---------------------------------------------------------------------------------------------------------\n      constructor: ->\n        @data = []\n        return undefined\n\n      #---------------------------------------------------------------------------------------------------------\n      toString: -> \"[#{ ( \"#{e}\" for e in @data ).join'.' }]\"\n\n      #---------------------------------------------------------------------------------------------------------\n      set_getter @::, 'length',   -> @data.length\n      set_getter @::, 'is_empty', -> @data.length is 0\n      clear: -> @data.length = 0; null\n      [Symbol.iterator]: -> yield from @data\n\n      #---------------------------------------------------------------------------------------------------------\n      push:     ( x ) -> @data.push x;    null\n      unshift:  ( x ) -> @data.unshift x; null\n\n      #---------------------------------------------------------------------------------------------------------\n      pop: ( fallback = misfit ) ->\n        if @is_empty\n          return fallback unless fallback is misfit\n          throw new XXX_Stack_error \"Ωidsp___4 unable to pop value from empty stack\"\n        return @data.pop()\n\n      #---------------------------------------------------------------------------------------------------------\n      shift: ( fallback = misfit ) ->\n        if @is_empty\n          return fallback unless fallback is misfit\n          throw new XXX_Stack_error \"Ωidsp___5 unable to shift value from empty stack\"\n        return @data.shift()\n\n      #---------------------------------------------------------------------------------------------------------\n      peek: ( fallback = misfit ) ->\n        if @is_empty\n          return fallback unless fallback is misfit\n          throw new XXX_Stack_error \"Ωidsp___6 unable to peek value of empty stack\"\n        return @data.at -1\n\n    #-----------------------------------------------------------------------------------------------------------\n    return { Stack, }\n\n  #===========================================================================================================\n  ### NOTE Future Single-File Module ###\n  require_infiniproxy: ->\n    ###\n\n    ## To Do\n\n    * **`[—]`** allow to set context to be used by `apply()`\n    * **`[—]`** allow to call `sys.stack.clear()` manually where seen fit\n\n    ###\n    { hide,               } = SFMODULES.require_managed_property_tools()\n    { Stack,              } = SFMODULES.require_stack_classes()\n    ### TAINT in this simulation of single-file modules, a new distinct symbol is produced with each call to\n    `require_infiniproxy()` ###\n    sys_symbol              = Symbol 'sys'\n    # misfit                  = Symbol 'misfit'\n    template                =\n      ### An object that will be checked for existing properties to return; when no provider is given or a\n      provider lacks a requested property, `sys.sub_level_proxy` will be returned for property accesses: ###\n      provider:     Object.create null\n      ### A function to be called when the proxy (either `sys.top_level_proxy` or `sys.sub_level_proxy`) is\n      called; notice that if the `provider` provides a method for a given key, that method will be called\n      instead of the `callee`: ###\n      callee:       null\n\n    #=========================================================================================================\n    create_infinyproxy = ( cfg ) ->\n      ### TAINT use proper typechecking ###\n      cfg = { template...,  cfg..., }\n      #.......................................................................................................\n      new_proxy = ({ is_top_level, }) ->\n        callee_ctx  = null\n        get_ctx     = -> callee_ctx ?= { is_top_level, cfg..., sys..., }\n        #.....................................................................................................\n        R = new Proxy cfg.callee,\n\n          #-----------------------------------------------------------------------------------------------------\n          apply: ( target, key, P ) ->\n            # urge 'Ω__10', \"apply #{rpr { target, key, P, is_top_level, }}\"\n\n            R = Reflect.apply target, get_ctx(), P\n            sys.stack.clear()\n            return R\n\n          #-----------------------------------------------------------------------------------------------------\n          get: ( target, key ) ->\n            # urge 'Ω__11', \"get #{rpr { target, key, }}\"\n            return get_ctx()                      if key is sys_symbol\n            return target[ key ]                  if ( typeof key ) is 'symbol'\n            return Reflect.get cfg.provider, key  if Reflect.has cfg.provider, key\n            sys.stack.clear() if is_top_level\n            sys.stack.push key\n            # return \"[result for getting non-preset key #{rpr key}] from #{rpr provider}\"\n            return sys.sub_level_proxy\n        #.....................................................................................................\n        return R\n      #.......................................................................................................\n      sys = { stack: new Stack(), }\n      sys.top_level_proxy = new_proxy { is_top_level: true,  }\n      sys.sub_level_proxy = new_proxy { is_top_level: false, }\n      #.......................................................................................................\n      return sys.top_level_proxy\n\n    #---------------------------------------------------------------------------------------------------------\n    return { create_infinyproxy, sys_symbol, }\n"
  ]
}